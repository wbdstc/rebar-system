<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>钢筋工程全生命周期智能管控平台 V10.0</title>
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            background-color: #1a1c23;
            color: #e0e0e0;
            font-family: 'Segoe UI', sans-serif;
        }

        .card {
            background-color: #2c2f38;
            border: 1px solid #3a3f4b;
            margin-bottom: 20px;
            border-radius: 8px;
        }

        .card-header {
            background-color: #3a3f4b;
            color: #fff;
            border-bottom: 1px solid #48505e;
            padding: 12px 15px;
            font-weight: 600;
        }

        .form-control,
        .form-select {
            background-color: #22252b;
            border: 1px solid #444;
            color: #fff;
        }

        .form-control:focus,
        .form-select:focus {
            background-color: #2c2f38;
            color: #fff;
            border-color: #0d6efd;
            box-shadow: none;
        }

        .small-label {
            font-size: 0.8rem;
            color: #8b9bb4;
            margin-bottom: 4px;
            display: block;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            background: #111;
            border: 1px solid #444;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.5);
            min-height: 700px;
        }

        canvas {
            display: block;
            margin: 0 auto;
        }

        .legend-box {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(18, 28, 45, 0.95);
            padding: 15px;
            border: 1px solid #0d6efd;
            border-radius: 4px;
            z-index: 100;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            color: #d0d0d0;
        }

        .dot {
            width: 10px;
            height: 10px;
            margin-right: 8px;
            border-radius: 2px;
        }

        /* 模式切换的大按钮 */
        .mode-switch-btn {
            cursor: pointer;
            opacity: 0.6;
            transition: 0.3s;
            border: 2px solid transparent;
        }

        .mode-switch-btn:hover {
            opacity: 1;
        }

        .mode-switch-btn.active {
            opacity: 1;
            border-color: #0d6efd;
            background: #22252b;
        }
    </style>
</head>

<body>

    <div class="container-fluid px-4 py-4">
        <!-- 面包屑导航 -->
        <nav class="mb-3">
            <a href="portal.html" class="text-decoration-none text-secondary"><i class="fas fa-home"></i> 首页</a>
            <span class="text-secondary mx-2">/</span>
            <span class="text-white" id="breadcrumbCurrent">智能验收</span>
        </nav>

        <div class="d-flex justify-content-between align-items-center mb-4 pb-2 border-bottom border-secondary">
            <div class="d-flex align-items-center gap-4">
                <div>
                    <h3 class="text-white fw-bold mb-0"><i class="fas fa-project-diagram"></i> 钢筋全生命周期智能管控平台</h3>
                    <div class="text-secondary small">V10.0 终极双核版 (Dual-Engine)</div>
                </div>
                <!-- 场景切换按钮组 -->
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-outline-primary active" id="btnModeSpacing"
                        onclick="switchMode('spacing')">
                        <i class="fas fa-border-all"></i> 隐蔽验收
                    </button>
                    <button type="button" class="btn btn-outline-warning" id="btnModeCounting"
                        onclick="switchMode('counting')">
                        <i class="fas fa-layer-group"></i> 进场验收
                    </button>
                </div>
            </div>
            <div>
                <a href="portal.html" class="btn btn-outline-secondary btn-sm me-2"><i class="fas fa-arrow-left"></i>
                    返回首页</a>
                <button class="btn btn-outline-primary btn-sm" onclick="location.reload()"><i class="fas fa-sync"></i>
                    重置</button>
            </div>
        </div>

        <div class="row g-4">
            <div class="col-lg-3">


                <div class="card">
                    <div class="card-header"><i class="fas fa-sliders-h"></i> 参数与标定</div>
                    <div class="card-body">

                        <div id="panelSpacing">
                            <label class="small-label text-info">构件类型 (平法)</label>
                            <select class="form-select mb-3" id="spacingType" onchange="redrawCanvas()">
                                <option value="slab">板/墙 (@150 标准)</option>
                                <option value="beam">梁/柱 (加密区检测)</option>
                            </select>

                            <label class="small-label">设计间距</label>
                            <select class="form-select mb-3" id="stdDist" onchange="redrawCanvas()">
                                <option value="100">@100 (加密)</option>
                                <option value="150" selected>@150 (标准)</option>
                                <option value="200">@200 (非加密)</option>
                            </select>

                            <div class="alert alert-dark small p-2 mb-2 text-secondary">
                                <i class="fas fa-mouse-pointer"></i> <b>操作：</b>上传图片后，请分别点击【底部】和【顶部】进行标定。
                            </div>
                            <div class="d-flex gap-2 mb-2">
                                <button class="btn btn-outline-warning btn-sm w-50"
                                    onclick="startCalibration('bottom')">标定底部</button>
                                <button class="btn btn-outline-warning btn-sm w-50"
                                    onclick="startCalibration('top')">标定顶部</button>
                            </div>
                            <div class="input-group input-group-sm mb-3">
                                <span class="input-group-text bg-dark text-secondary">真值</span>
                                <input type="number" id="refLenSpacing" class="form-control text-end text-white"
                                    value="80">
                                <span class="input-group-text bg-dark text-secondary">mm</span>
                            </div>
                        </div>

                        <div id="panelCounting" style="display:none;">
                            <div class="alert alert-dark small p-2 mb-3 text-secondary">
                                <i class="fas fa-vector-square"></i> <b>操作：</b>上传图片后，在参照物（如银行卡）上<b>拖拽画框</b>。
                            </div>
                            <div class="input-group input-group-sm mb-3">
                                <span class="input-group-text bg-dark text-secondary">参照物宽</span>
                                <input type="number" id="refLenCounting" class="form-control text-end text-white"
                                    value="85.6">
                                <span class="input-group-text bg-dark text-secondary">mm</span>
                            </div>
                        </div>

                        <hr class="border-secondary">
                        <input type="file" id="fileInput" class="form-control mb-3" accept="image/*">
                        <button class="btn btn-primary w-100 fw-bold py-2" onclick="startAnalysis()">
                            <i class="fas fa-bolt"></i> 开始智能识别
                        </button>
                    </div>
                </div>

                <div class="card bg-dark">
                    <div class="card-body text-center p-3">
                        <div class="row">
                            <div class="col-6 border-end border-secondary">
                                <div class="h4 text-white mb-0" id="stat1">-</div>
                                <div class="small text-secondary" id="label1">数量</div>
                            </div>
                            <div class="col-6">
                                <div class="h4 text-info mb-0" id="stat2">-</div>
                                <div class="small text-secondary" id="label2">合格率</div>
                            </div>
                        </div>
                        <div id="chartContainer" style="display:none; margin-top:15px;">
                            <canvas id="diaChart" height="150"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-lg-9">
                <div class="canvas-wrapper">
                    <div class="legend-box" id="legendBox"></div>
                    <canvas id="mainCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        let imgObj = new Image();
        let chartInstance = null;

        // --- 全局状态 ---
        let appState = {
            mode: 'spacing', // 'spacing' | 'counting'
            predictions: [],

            // 间距模式标定 (点两点)
            calibMode: null, calibPoints: [],
            scaleBottom: 0, scaleTop: 0, scaleBottomY: 0, scaleTopY: 0,

            // 计数模式标定 (画框)
            refBox: null, isDrawing: false, startX: 0, startY: 0, singleScale: 0
        };

        // --- 1. 模式切换 ---
        function switchMode(mode) {
            appState.mode = mode;
            // UI 更新
            document.getElementById('btnModeSpacing').className = `btn btn-outline-primary ${mode === 'spacing' ? 'active' : ''}`;
            document.getElementById('btnModeCounting').className = `btn btn-outline-warning ${mode === 'counting' ? 'active' : ''}`;

            document.getElementById('panelSpacing').style.display = mode === 'spacing' ? 'block' : 'none';
            document.getElementById('panelCounting').style.display = mode === 'counting' ? 'block' : 'none';

            document.getElementById('label1').innerText = mode === 'spacing' ? '钢筋根数' : '总数量';
            document.getElementById('label2').innerText = mode === 'spacing' ? '合格率' : '平均直径';
            document.getElementById('chartContainer').style.display = mode === 'counting' ? 'block' : 'none';

            // 清空结果
            appState.predictions = [];
            redrawCanvas();
            updateStats();

            // 更新面包屑
            document.getElementById('breadcrumbCurrent').innerText = mode === 'spacing' ? '隐蔽验收' : '进场验收';
        }

        // --- 初始化：读取 URL 参数 ---
        (function init() {
            const params = new URLSearchParams(window.location.search);
            const mode = params.get('mode');
            if (mode === 'counting' || mode === 'spacing') {
                switchMode(mode);
            }
        })();

        // --- 2. 图片加载 ---
        document.getElementById('fileInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (event) {
                imgObj.onload = function () {
                    // 重置所有标定数据
                    appState.predictions = [];
                    appState.calibPoints = []; appState.refBox = null;
                    appState.scaleBottom = 0; appState.scaleTop = 0; appState.singleScale = 0;

                    canvas.width = imgObj.width; canvas.height = imgObj.height;
                    redrawCanvas();
                }
                imgObj.src = event.target.result;
            }
            reader.readAsDataURL(file);
        });

        // --- 3. 交互逻辑 (根据模式分流) ---

        // 鼠标按下
        canvas.addEventListener('mousedown', e => {
            if (!imgObj.src) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;

            if (appState.mode === 'spacing') {
                // V8.0 逻辑: 点两点
                if (!appState.calibMode) return;
                appState.calibPoints.push({ x: mx, y: my });
                if (appState.calibPoints.length === 2) finishCalibrationSpacing();
                redrawCanvas();

            } else {
                // V9.0 逻辑: 拖拽画框
                appState.isDrawing = true;
                appState.startX = mx; appState.startY = my;
                appState.refBox = { x: mx, y: my, w: 0, h: 0 };
            }
        });

        // 鼠标移动
        canvas.addEventListener('mousemove', e => {
            if (appState.mode === 'counting' && appState.isDrawing) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mx = (e.clientX - rect.left) * scaleX;
                const my = (e.clientY - rect.top) * scaleY;
                appState.refBox.w = mx - appState.startX;
                appState.refBox.h = my - appState.startY;
                redrawCanvas();
            }
        });

        // 鼠标抬起
        canvas.addEventListener('mouseup', e => {
            if (appState.mode === 'counting' && appState.isDrawing) {
                appState.isDrawing = false;
                // 计算单一比例尺
                if (Math.abs(appState.refBox.w) > 5) {
                    const pxW = Math.abs(appState.refBox.w);
                    const realW = parseFloat(document.getElementById('refLenCounting').value);
                    appState.singleScale = pxW / realW;
                    if (appState.predictions.length > 0) updateStats();
                }
                redrawCanvas();
            }
        });

        // 间距模式的标定辅助函数
        function startCalibration(pos) {
            if (!imgObj.src) return alert("请上传图片");
            appState.calibMode = pos; appState.calibPoints = [];
            alert(`请在图片${pos === 'bottom' ? '底部' : '顶部'}点击参照物首尾`);
        }
        function finishCalibrationSpacing() {
            const p1 = appState.calibPoints[0]; const p2 = appState.calibPoints[1];
            const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            const real = parseFloat(document.getElementById('refLenSpacing').value);
            const scale = dist / real;
            const avgY = (p1.y + p2.y) / 2;
            if (appState.calibMode === 'bottom') { appState.scaleBottom = scale; appState.scaleBottomY = avgY; }
            else { appState.scaleTop = scale; appState.scaleTopY = avgY; }
            appState.calibMode = null; appState.calibPoints = [];
        }

        // --- 4. 请求后端 ---
        async function startAnalysis() {
            if (!imgObj.src) return alert("请上传图片");
            const btn = document.querySelector('button[onclick="startAnalysis()"]');
            const oldHtml = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 正在调用 AI...'; btn.disabled = true;

            try {
                const maxSide = 1280;
                let w = imgObj.width, h = imgObj.height;
                if (w > maxSide || h > maxSide) { const r = Math.min(maxSide / w, maxSide / h); w *= r; h *= r; }
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = w; tempCanvas.height = h;
                tempCanvas.getContext('2d').drawImage(imgObj, 0, 0, w, h);

                tempCanvas.toBlob(async function (blob) {
                    const formData = new FormData();
                    formData.append('image', blob);

                    // 【核心】根据当前模式，告诉后端用哪个模型
                    // mode=spacing -> 用网格模型; mode=counting -> 用计数模型
                    const url = `/analyze?mode=${appState.mode}&conf=40&overlap=40`;

                    const res = await fetch(url, { method: 'POST', body: formData });
                    const data = await res.json();
                    if (data.predictions) {
                        appState.predictions = data.predictions;
                        redrawCanvas();
                        updateStats();
                    }
                    btn.innerHTML = oldHtml; btn.disabled = false;
                }, 'image/jpeg', 0.85);
            } catch (err) { btn.innerHTML = oldHtml; btn.disabled = false; }
        }

        // --- 5. 绘图与逻辑 (双脑核心) ---
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(imgObj, 0, 0);

            // A. 间距模式绘图逻辑 (V8.0)
            if (appState.mode === 'spacing') {
                // 绘制标定点
                if (appState.calibPoints.length > 0) {
                    ctx.strokeStyle = "cyan"; ctx.lineWidth = 2; ctx.beginPath();
                    appState.calibPoints.forEach(p => { ctx.lineTo(p.x, p.y); ctx.fillStyle = "cyan"; ctx.fillRect(p.x - 3, p.y - 3, 6, 6) });
                    ctx.stroke();
                }

                // 图例更新
                const lg = document.getElementById('legendBox');
                const std = document.getElementById('stdDist').value;
                lg.innerHTML = `
                <div class="legend-item"><div class="dot" style="background:#00e676;"></div>符合 @${std}</div>
                <div class="legend-item"><div class="dot" style="background:#ff1744;"></div>超标</div>
            `;

                if (appState.predictions.length > 0) {
                    // 绘制 Mask
                    let verticals = [], horizontals = [];
                    appState.predictions.forEach(p => {
                        if (p.points) {
                            ctx.beginPath(); ctx.moveTo(p.points[0].x, p.points[0].y);
                            for (let i = 1; i < p.points.length; i++) ctx.lineTo(p.points[i].x, p.points[i].y);
                            ctx.fillStyle = "rgba(255,215,0,0.2)"; ctx.fill();
                        }
                        if (p.height > p.width) verticals.push(p); else horizontals.push(p);
                    });
                    verticals.sort((a, b) => a.x - b.x); horizontals.sort((a, b) => a.y - b.y);

                    // 测量间距 (简化版)
                    let passCount = 0, count = 0;
                    function measure(items, isVert) {
                        for (let i = 0; i < items.length - 1; i++) {
                            let p1 = items[i], p2 = items[i + 1];
                            let aligned = isVert ? (Math.min(p1.y + p1.height / 2, p2.y + p2.height / 2) > Math.max(p1.y - p1.height / 2, p2.y - p2.height / 2)) : (Math.min(p1.x + p1.width / 2, p2.x + p2.width / 2) > Math.max(p1.x - p1.width / 2, p2.x - p2.width / 2));
                            if (!aligned) continue;
                            let distPx = isVert ? (p2.x - p1.x) : (p2.y - p1.y);
                            if (Math.abs(distPx) < 10) continue;

                            // 动态比例尺插值
                            let scale = 1;
                            if (appState.scaleBottom > 0 && appState.scaleTop > 0) {
                                const range = appState.scaleBottomY - appState.scaleTopY;
                                const ratio = (((p1.y + p2.y) / 2) - appState.scaleTopY) / range;
                                scale = appState.scaleTop + (appState.scaleBottom - appState.scaleTop) * ratio;
                            } else if (appState.scaleBottom > 0) scale = appState.scaleBottom;

                            let distMm = Math.abs(distPx) / scale;
                            if (distMm > parseFloat(std) * 2.5) continue;
                            let isPass = Math.abs(distMm - std) <= 15;
                            if (isPass) passCount++; count++;

                            ctx.strokeStyle = isPass ? "#00e676" : "#ff1744"; ctx.lineWidth = 2; ctx.beginPath();
                            let tx, ty;
                            if (isVert) { let my = (p1.y + p2.y) / 2; ctx.moveTo(p1.x, my); ctx.lineTo(p2.x, my); tx = (p1.x + p2.x) / 2; ty = my; }
                            else { let mx = (p1.x + p2.x) / 2; ctx.moveTo(mx, p1.y); ctx.lineTo(mx, p2.y); tx = mx; ty = (p1.y + p2.y) / 2; }
                            ctx.stroke();
                            let txt = distMm.toFixed(0); ctx.fillStyle = "#fff"; ctx.font = "12px Arial"; ctx.fillText(txt, tx, ty);
                        }
                    }
                    measure(verticals, true); measure(horizontals, false);
                    document.getElementById('stat1').innerText = verticals.length + horizontals.length;
                    document.getElementById('stat2').innerText = count > 0 ? ((passCount / count) * 100).toFixed(0) + "%" : "-";
                }
            }

            // B. 计数模式绘图逻辑 (V9.0)
            else if (appState.mode === 'counting') {
                const lg = document.getElementById('legendBox');
                lg.innerHTML = `<div class="legend-item"><div class="dot" style="background:#00e676;"></div>钢筋端面</div>`;

                // 画参照物框
                if (appState.refBox && appState.refBox.w !== 0) {
                    ctx.strokeStyle = "#ff9800"; ctx.lineWidth = 3; ctx.setLineDash([5, 5]);
                    ctx.strokeRect(appState.refBox.x, appState.refBox.y, appState.refBox.w, appState.refBox.h);
                    ctx.setLineDash([]); ctx.fillStyle = "#ff9800"; ctx.fillText("参照物", appState.refBox.x, appState.refBox.y - 5);
                }

                if (appState.predictions.length > 0) {
                    appState.predictions.forEach(p => {
                        const x = p.x - p.width / 2; const y = p.y - p.height / 2;
                        ctx.strokeStyle = "#00e676"; ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, p.width, p.height);

                        if (appState.singleScale > 0) {
                            let dia = (Math.min(p.width, p.height) / appState.singleScale).toFixed(1);
                            ctx.fillStyle = "#fff"; ctx.fillText(dia, p.x, p.y);
                        }
                    });
                }
            }
        }

        // --- 6. 统计更新 ---
        function updateStats() {
            if (appState.mode === 'counting') {
                document.getElementById('stat1').innerText = appState.predictions.length;

                if (appState.singleScale > 0 && appState.predictions.length > 0) {
                    let dias = appState.predictions.map(p => Math.min(p.width, p.height) / appState.singleScale);
                    let total = dias.reduce((a, b) => a + b, 0);
                    document.getElementById('stat2').innerText = "φ" + (total / dias.length).toFixed(1);

                    // 更新图表
                    let dist = { 'φ10': 0, 'φ12': 0, 'φ14': 0, 'φ16': 0, 'φ18': 0, 'φ20': 0, 'φ22': 0, 'φ25': 0 };
                    dias.forEach(d => {
                        for (let k in dist) {
                            let std = parseInt(k.replace('φ', ''));
                            if (Math.abs(d - std) <= 1.2) { dist[k]++; break; }
                        }
                    });
                    const ctxChart = document.getElementById('diaChart').getContext('2d');
                    if (chartInstance) chartInstance.destroy();
                    chartInstance = new Chart(ctxChart, {
                        type: 'bar',
                        data: { labels: Object.keys(dist), datasets: [{ label: '数量', data: Object.values(dist), backgroundColor: '#00bcd4' }] },
                        options: { plugins: { legend: { display: false } }, scales: { x: { grid: { display: false } }, y: { grid: { color: '#444' } } } }
                    });
                } else {
                    document.getElementById('stat2').innerText = "-";
                }
            }
        }
    </script>
</body>

</html>